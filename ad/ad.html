<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Algorithmen & Datenstrukturen</h1>
<h2 class="author">Patrick Bucher</h2>
</div>
<div id="TOC">
<ul>
<li><a href="#einführung"><span class="toc-section-number">1</span> Einführung</a><ul>
<li><a href="#was-ist-ein-algorithmus"><span class="toc-section-number">1.1</span> Was ist ein Algorithmus?</a></li>
<li><a href="#was-ist-eine-datenstruktur"><span class="toc-section-number">1.2</span> Was ist eine Datenstruktur?</a></li>
<li><a href="#was-ist-ein-programm"><span class="toc-section-number">1.3</span> Was ist ein Programm?</a></li>
<li><a href="#fragen-betreffend-algorithmendatenstrukturen"><span class="toc-section-number">1.4</span> Fragen betreffend Algorithmen/Datenstrukturen</a></li>
<li><a href="#beispiel-berechnung-des-ggt"><span class="toc-section-number">1.5</span> Beispiel: Berechnung des ggT</a></li>
<li><a href="#gleichwertigkeit"><span class="toc-section-number">1.6</span> Gleichwertigkeit</a></li>
<li><a href="#komplexität"><span class="toc-section-number">1.7</span> Komplexität</a><ul>
<li><a href="#beispiel"><span class="toc-section-number">1.7.1</span> Beispiel</a></li>
<li><a href="#big-o-notation"><span class="toc-section-number">1.7.2</span> Big-O-Notation</a></li>
<li><a href="#abschliessende-bemerkungen"><span class="toc-section-number">1.7.3</span> Abschliessende Bemerkungen</a></li>
</ul></li>
</ul></li>
<li><a href="#rekursion"><span class="toc-section-number">2</span> Rekursion</a><ul>
<li><a href="#rekursion-vs.iteration-am-beispiel-der-fakultät"><span class="toc-section-number">2.1</span> Rekursion vs. Iteration (am Beispiel der Fakultät)</a><ul>
<li><a href="#iterativer-ansatz"><span class="toc-section-number">2.1.1</span> Iterativer Ansatz</a></li>
<li><a href="#rekursiver-ansatz"><span class="toc-section-number">2.1.2</span> Rekursiver Ansatz</a></li>
</ul></li>
<li><a href="#mächtigkeit-der-rekursion"><span class="toc-section-number">2.2</span> Mächtigkeit der Rekursion</a><ul>
<li><a href="#beispiel-fibonacci-zahl"><span class="toc-section-number">2.2.1</span> Beispiel: Fibonacci-Zahl</a></li>
</ul></li>
<li><a href="#typen-von-rekursion"><span class="toc-section-number">2.3</span> Typen von Rekursion</a></li>
<li><a href="#beispiel-permutation"><span class="toc-section-number">2.4</span> Beispiel: Permutation</a></li>
</ul></li>
<li><a href="#collections"><span class="toc-section-number">3</span> Collections</a><ul>
<li><a href="#eigenschaften-von-datenstrukturen"><span class="toc-section-number">3.1</span> Eigenschaften von Datenstrukturen</a></li>
<li><a href="#das-java-collection-framework"><span class="toc-section-number">3.2</span> Das Java Collection Framework</a><ul>
<li><a href="#grundlegende-funktionen-für-das-funktionieren-des-collection-frameworks"><span class="toc-section-number">3.2.1</span> Grundlegende Funktionen für das Funktionieren des Collection-Frameworks</a></li>
<li><a href="#arten-der-gleichheit"><span class="toc-section-number">3.2.2</span> Arten der Gleichheit</a></li>
</ul></li>
<li><a href="#beispiel-speicherverwaltung"><span class="toc-section-number">3.3</span> Beispiel: Speicherverwaltung</a><ul>
<li><a href="#anforderungen-an-die-speicherverwaltung"><span class="toc-section-number">3.3.1</span> Anforderungen an die Speicherverwaltung</a></li>
</ul></li>
</ul></li>
<li><a href="#datenstrukturen"><span class="toc-section-number">4</span> Datenstrukturen</a><ul>
<li><a href="#eigenschaften-von-datenstrukturen-1"><span class="toc-section-number">4.1</span> Eigenschaften von Datenstrukturen</a></li>
<li><a href="#operationen-auf-datenstrukturen"><span class="toc-section-number">4.2</span> Operationen auf Datenstrukturen</a></li>
<li><a href="#statisch-oder-dynamisch"><span class="toc-section-number">4.3</span> Statisch oder dynamisch</a></li>
<li><a href="#element-beziehungen-explizit-oder-implizit"><span class="toc-section-number">4.4</span> Element-Beziehungen: explizit oder implizit</a></li>
<li><a href="#zugriff-direkt-oder-indirekt-sequenziell"><span class="toc-section-number">4.5</span> Zugriff: direkt oder indirekt (sequenziell)</a></li>
<li><a href="#aufwand-von-operationen"><span class="toc-section-number">4.6</span> Aufwand von Operationen</a></li>
<li><a href="#array"><span class="toc-section-number">4.7</span> Array</a><ul>
<li><a href="#binäre-suche"><span class="toc-section-number">4.7.1</span> Binäre Suche</a></li>
<li><a href="#einfügen"><span class="toc-section-number">4.7.2</span> Einfügen</a></li>
<li><a href="#entfernen"><span class="toc-section-number">4.7.3</span> Entfernen</a></li>
<li><a href="#empfehlungen"><span class="toc-section-number">4.7.4</span> Empfehlungen</a></li>
</ul></li>
<li><a href="#listen"><span class="toc-section-number">4.8</span> Listen</a></li>
<li><a href="#stack"><span class="toc-section-number">4.9</span> Stack</a></li>
<li><a href="#queue"><span class="toc-section-number">4.10</span> Queue</a></li>
</ul></li>
<li><a href="#glossar"><span class="toc-section-number">5</span> Glossar</a></li>
</ul>
</div>
<h1 id="einführung"><span class="header-section-number">1</span> Einführung</h1>
<h2 id="was-ist-ein-algorithmus"><span class="header-section-number">1.1</span> Was ist ein Algorithmus?</h2>
<p>Ein Algorithmus ist ein präzise festgelegtes <em>Verfahren zur Lösung eines Problems</em> bzw. einer Problemklasse; ein Lösungsverfahren (Rezept, Anleitung).</p>
<p>Eigenschaften eines Algorithmus:</p>
<ol style="list-style-type: decimal">
<li>schrittweises Verfahren</li>
<li>ausführbare Schritte</li>
<li>eindeutiger nächster Schritt (determiniert)</li>
<li>endet nach endlich vielen Schritten (terminiert)</li>
</ol>
<p>Beispiele für Algorithmen:</p>
<ul>
<li>Berechnung des ggT</li>
<li>Zeichnen von Verbindungslinien</li>
<li>Sortierung von Zahlen</li>
<li>Finden des kürzesten Weges zwischen zwei Punkten</li>
<li>Primzahltest</li>
<li>Berechnung eines Integrals</li>
<li>Finden einer Lösung in einem Lösungsraum</li>
</ul>
<p>Themenbereiche von Algorithmen:</p>
<ul>
<li>Algorithmentheorie: Finden guter Lösungsalgorithmen für bestimmte Problemstellungen</li>
<li>Komplexitätstheorie: Ressourcenverbrauch (Rechenzeit, Speicherbedarf)</li>
<li>Berechenbarkeitstheorie: Was ist mit einer Maschine lösbar/nicht lösbar?</li>
</ul>
<h2 id="was-ist-eine-datenstruktur"><span class="header-section-number">1.2</span> Was ist eine Datenstruktur?</h2>
<p>Eine Datenstruktur ist ein Konzept zur <em>Speicherung und Organisation von Daten</em>. Sie ist durch die Operationen charakterisiert, welche Zugriffe und Verwaltung realisieren.</p>
<p>Beispiele für Datenstrukturen:</p>
<ul>
<li>Array: direkter Zugriff, fixe Grösse</li>
<li>Liste: sequentieller Zugriff, flexible Grösse</li>
</ul>
<h2 id="was-ist-ein-programm"><span class="header-section-number">1.3</span> Was ist ein Programm?</h2>
<p>Ein Programm kombiniert Algorithmen und Datenstrukturen.</p>
<p>Der Ressourcenverbrauch eines Algorithmus (Laufzeit und Speicherbedarf) hängt von der Verwendung geeigneter Datenstrukturen ab.</p>
<p>Algorithmen operieren auf Datenstrukturen und Datenstrukturen bedingen spezifische Algorithmen.</p>
<h2 id="fragen-betreffend-algorithmendatenstrukturen"><span class="header-section-number">1.4</span> Fragen betreffend Algorithmen/Datenstrukturen</h2>
<ol style="list-style-type: decimal">
<li>Für kleine oder grosse Probleme adäquat?</li>
<li>Selber entwickeln oder aus einer Bibliothek?</li>
<li>Einfach oder schwierig zu verstehen, implementieren und warten?</li>
<li>Geringe Laufzeit mit grossem Speicherbedarf oder umgekehrt?</li>
</ol>
<h2 id="beispiel-berechnung-des-ggt"><span class="header-section-number">1.5</span> Beispiel: Berechnung des ggT</h2>
<p>Gegeben sind zwei Zahlen, A und B.</p>
<ol style="list-style-type: decimal">
<li>A sei die grössere der beiden Zahlen (andernfalls tauschen).</li>
<li>Setze <code>A = A - B</code></li>
<li>Wenn <code>A != B</code>: Schritt 1, wenn <code>A = B</code>: Fertig</li>
</ol>
<p>Iterative Lösung (mit impliziter Vertauschung):</p>
<pre><code>public static int ggT(int a, int b) {
    while (a != b) {
        if (a &gt; b) {
            a = a - b;
        } else {
            b = b - a;
        }
    }
    return a;
}</code></pre>
<p>Iterative Lösung (mit Modulo-Operator “abgekürzt”):</p>
<pre><code>public static int ggT(int a, int b) {
    while ((a != b) &amp;&amp; (b != 0)) {
        if (a &gt; b) {
            a = a % b;
        } else {
            b = b % a;
        }
    }
    return (a + b);
}</code></pre>
<p>Rekursive Lösung:</p>
<pre><code>public static int ggT(int a, int b) {
    if (a &gt; b) {
        ggT(a - b, b);
    } else {
        if (a &lt; b) {
            return ggT(a, b - a);
        } else {
            return a;
        }
    }
}</code></pre>
<h2 id="gleichwertigkeit"><span class="header-section-number">1.6</span> Gleichwertigkeit</h2>
<ul>
<li>Alle Implementierungen führen zum Ziel und liefern die gleichen Resultate. Sie sind <em>gleichwertig</em>.</li>
<li>Die Anzahl Schleifendurchläufe, arithmetische Operationen und Methodenaufrufe – und somit Laufzeit und Speicherbedarf – unterscheiden sich jedoch.</li>
</ul>
<ol style="list-style-type: decimal">
<li>Zu jeder Problemklasse gibt es verschiedene konkrete Probleme.</li>
<li>Zu jedem konkreten Problem gibt es verschiedene Algorithmen.</li>
<li>Zu jedem Algorithmus gibt es verschiedene Implementierungen.</li>
</ol>
<p>Die Gleichwertigkeit von Algorithmen kann nicht bewiesen werden (Halting-Problem).</p>
<h2 id="komplexität"><span class="header-section-number">1.7</span> Komplexität</h2>
<ul>
<li>Die Komplexität (oder Aufwand, Kosten) eines Algorithmus besagt, wie der Ressourcenbedarf von den Eingabedaten abhängt.</li>
<li>Der Ressourcenbedarf ist eine Funktion der Eingabedaten: <code>R=f(E)</code>
<ul>
<li>Rechenzeit: <em>Zeitkomplexität</em></li>
<li>Speicherbedarf: <em>Speicherkomplexität</em></li>
</ul></li>
<li>Abhängigkeit von Eingabedaten:
<ul>
<li>Grösse der <em>Datenmenge</em> (z.B. Anzahl zu sortierender Elemente)</li>
<li>Grösse der <em>Datenwerte</em> (z.B. Grössse zu prüfender Primzahlen)</li>
</ul></li>
</ul>
<p>Bei der Komplexität eines Algorithmus geht es nicht um die exakte Rechenzeit (einer Implementierung), sondern um das <em>Anwachsen des Ressourcenbedarfs</em> in Abhängigkeit von wachsenden Eingabedaten.</p>
<h3 id="beispiel"><span class="header-section-number">1.7.1</span> Beispiel</h3>
<p>Laufzeit eines Programms abhängig vom Eingabeparameter <code>n</code>:</p>
<pre><code>public static void task(int n) {
    task1();
    task1();
    task1();
    task1();
    for (int i = 0; i &lt; n; i++) {
        task2();
        task2();
        task2();
        for (int j = 0; j &lt; n; j++) {
            task3();
            task3();
        }
    }
}</code></pre>
<p>Annahmen:</p>
<ul>
<li>Die Methoden <code>task1</code>, <code>task2</code> und <code>task3</code> haben eine konstante und vergleichbare Rechenzeit und sind <em>nicht</em> vom Eingabeparameter <code>n</code> abhängig.</li>
<li>Die Ausführungszeiten der Schleifensteuerung sind vernachlässigbar.</li>
</ul>
<p>Berechnung: Die Rechenzeit <code>T</code> von <code>task(n)</code> beträgt <code>T=f(n)~4+3n+2n²</code></p>
<p>Folgerung:</p>
<ul>
<li>Für grosse <code>n</code> dominiert der Anteil von <code>n²</code>.</li>
<li>Die Funktion ist von der Ordnung <code>O(n²)</code></li>
</ul>
<h3 id="big-o-notation"><span class="header-section-number">1.7.2</span> Big-O-Notation</h3>
<ul>
<li><code>O</code>, das landausche Symbol, bringt zum Ausdruck, dass eine Funktion <code>f(n)</code> höchstens so schnell wächst wie eine andere Funktion <code>g(n)</code>.</li>
<li>Wird <code>n</code> genügend gross gewählt, unterscheiden sich <code>f(n)</code> und <code>g(n)</code> nur noch durch eine Konstante.</li>
</ul>
<p>Wichtige Ordnungsfunktionen:</p>
<table>
<thead>
<tr class="header">
<th>Bezeichnung</th>
<th>Notation</th>
<th>Beispiele</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Konstant</td>
<td><code>O(1)</code></td>
<td>Hashing</td>
</tr>
<tr class="even">
<td>Logarithmisch</td>
<td><code>O(ln(n))</code></td>
<td>binäres Suchen</td>
</tr>
<tr class="odd">
<td>Linear</td>
<td><code>O(n)</code></td>
<td>Suchen in Text</td>
</tr>
<tr class="even">
<td><code>n*log(n)</code></td>
<td><code>O(n*log(n))</code></td>
<td>schlaues Sortieren</td>
</tr>
<tr class="odd">
<td>Polynominal</td>
<td><code>O(n^m)</code></td>
<td>einfaches Sortieren</td>
</tr>
<tr class="even">
<td>Exponential</td>
<td><code>O(m^n)</code></td>
<td>Optimierungen</td>
</tr>
<tr class="odd">
<td>Fakultät</td>
<td><code>O(n!)</code></td>
<td>Permutationen, Travelling Salesman</td>
</tr>
</tbody>
</table>
<h3 id="abschliessende-bemerkungen"><span class="header-section-number">1.7.3</span> Abschliessende Bemerkungen</h3>
<ul>
<li>Die Ordnung macht keine Aussage über das Verhalten bei kleinen <code>n</code>.</li>
<li>Konstante Faktoren können bei kleinen <code>n</code> relevant sein.</li>
<li>Die exakte mathematische Analyse vieler Algorithmen ist schwierig oder sogar unmöglich.</li>
<li>Bei der Analyse muss darum differenziert werden:
<ul>
<li>bester Fall (best case)</li>
<li>schlechtester Fall (worst case)</li>
<li>mittlerer Fall (average case)</li>
</ul></li>
</ul>
<h1 id="rekursion"><span class="header-section-number">2</span> Rekursion</h1>
<p>Viele Algorithmen und Datenstrukturen sind von Natur aus <em>selbstähnlich</em> bzw. <em>selbstbezüglich</em>.</p>
<ul>
<li>Der ggT von 21 und 15 ist gleich dem ggt von 21-15 und 15.</li>
<li>Ein Verzeichnis enthält Daten und andere Verzeichnisse.</li>
<li>Ein Ausschnitt einer Matrix, einer Liste, eines Baumes, eines Graphen ist wiederum eine Matrix, eine Liste, ein Baum, ein Graph.</li>
</ul>
<h2 id="rekursion-vs.iteration-am-beispiel-der-fakultät"><span class="header-section-number">2.1</span> Rekursion vs. Iteration (am Beispiel der Fakultät)</h2>
<h3 id="iterativer-ansatz"><span class="header-section-number">2.1.1</span> Iterativer Ansatz</h3>
<p>Iterative Definition: <code>n! = 1*2*3*...*n</code></p>
<p>Iterative Implementierung:</p>
<pre><code>public static factorial(int n) {
    int result = 1;
    for (int i = 0; i &lt;= n; i++) {
        result *= i;
    }
    return result;
}</code></pre>
<h3 id="rekursiver-ansatz"><span class="header-section-number">2.1.2</span> Rekursiver Ansatz</h3>
<p>Rekursive Definition:</p>
<ul>
<li>Rekursionsbasis:
<ul>
<li><code>0! = 1</code></li>
<li><code>1! = 1</code></li>
</ul></li>
<li>Rekursionsvorschrift: <code>n!=n*(n-1)!</code></li>
<li>Rekursion: Aufzeigen eines Lösungsweges, wie ein schwieriges Problem auf ein gleichartiges aber einfacheres Problem zurückgeführt werden kann.</li>
</ul>
<p>Beispiel: <code>5!</code> wird auf die Rekursionsbasis zurückgeführt:</p>
<pre><code>- `5!=5*4!`
- `5!=5*(4*3!)`
- `5!=5*(4*(3*2!))`
- `5!=5*(4*(3*(2*1!)))=5*(4*(3*(2*1)))=120`</code></pre>
<p>Rekursive Implementierung:</p>
<pre><code>public static factorial(int n) {
    if (n == 0 || n == 1) {
        // Iterationsbasis
        return 1;
    } else {
        // Rekursionsvorschrift (Rückführung)
        return n * factorial(n - 1);
    }
}</code></pre>
<h2 id="mächtigkeit-der-rekursion"><span class="header-section-number">2.2</span> Mächtigkeit der Rekursion</h2>
<ul>
<li>Rekursion und Iteration sind <em>gleich mächtig</em>.</li>
<li>Die Menge der berechenbaren Problemstellungen bei Verwendung von Rekursion und Iteration ist gleich.</li>
<li>Eine iterative Implementierung lässt sich immer in eine rekursive Implementierung überführen (und umgekehrt).</li>
<li>Vorteile der Rekursion:
<ul>
<li>Rekursive Ansätze sind oft einfach und elegant.</li>
<li>Die Korrektheit rekursiver Definitionen lässt sich oft einfacher aufzeigen.</li>
<li>Es gibt rein rekursive Programmiersprachen, z.B. LISP und Prolog</li>
</ul></li>
<li>Nachteile der Rekursion:
<ul>
<li>Es ergeben sich schnell sehr viele Methodenaufrufe.</li>
<li>Die Programmausführung ist dadurch tendenziell langsamer.</li>
<li>Es besteht grosser Speicherbedarf auf dem Call-Stack und die Gefahr für einen Stack Overflow.</li>
</ul></li>
</ul>
<h3 id="beispiel-fibonacci-zahl"><span class="header-section-number">2.2.1</span> Beispiel: Fibonacci-Zahl</h3>
<ul>
<li>Fibonacci-Zahlen sind in der Mathematik rekursiv definiert:
<ul>
<li><code>f(0)=0</code></li>
<li><code>f(1)=1</code></li>
<li><code>f(n)=f(n-1)+f(n-2)</code>, für <code>n&gt;=2</code></li>
</ul></li>
</ul>
<p>Rekursive Implementierung:</p>
<pre><code>public int fib(n) {
    if (n == 0 || n == 1) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}</code></pre>
<p>Probleme einer rekursiven Implementierung:</p>
<ul>
<li>Viele rekursive Aufrufe: Komplexitätsklasse <code>O(2^n)</code>.</li>
<li>Mehrfache Berechnung der gleichen Zahlen. (Lösungsansatz: Caching)</li>
<li>Besser eine iterative Lösung finden!</li>
<li><em>Nicht jedes Problem, das sich rekursiv präsentiert, sollte rekursiv umgesetzt werden!</em></li>
</ul>
<h2 id="typen-von-rekursion"><span class="header-section-number">2.3</span> Typen von Rekursion</h2>
<ul>
<li>linear vs. nichtlinear:
<ul>
<li><em>lineare Rekursion</em>: eine Methode ruft sich intern selber auf (z.B. Fakultät)
<ul>
<li><code>m() -&gt; m()</code></li>
</ul></li>
<li><em>nichtlineare Rekursion</em>: ein Methodenaufruf führt zu mehreren rekursiven Aufrufen (z.B. Fibonacci)
<ul>
<li>nicht geschachtelt (Fibonacci): <em>primitiv rekursiv</em>, <code>m() -&gt; m(); m();</code></li>
<li>geschachtelt: <em>nicht primitiv rekursiv</em>, <code>m() -&gt; m(m())</code></li>
</ul></li>
</ul></li>
<li>direkt vs. indirekt:
<ul>
<li><em>Direkte Rekursion</em>: eine Methode ruft sich <em>direkt</em> selber auf.</li>
<li><em>Indirekte Rekursion</em>: eine rekursive Methode ruft sich <em>indirekt</em> selber auf, <code>m() -&gt; m(n(m()))</code></li>
</ul></li>
</ul>
<h2 id="beispiel-permutation"><span class="header-section-number">2.4</span> Beispiel: Permutation</h2>
<p>Ein sechs Zeichen langes Passwort bestehend aus den Buchstaben von <code>A</code> bis <code>F</code>, wobei jeder Buchstabe nur einmal vorkommt, ist gesucht. Gefragt sind die <em>Permutationen</em> (alle möglichen Kombinationen) dieser Buchstaben. Es gibt <code>6!=720</code> mögliche Kombinationen:</p>
<ul>
<li><code>ABCDEF</code></li>
<li><code>BACDEF</code></li>
<li><code>...</code></li>
<li><code>FEDCBA</code></li>
</ul>
<p>Lösungsansatz: Rückführung des Problems (Permutation von <code>n</code> Zeichen auf Permutation von einem Zeichen)!</p>
<ul>
<li><code>A</code> kombiniert mit den Permutationen von <code>BCDEF</code>
<ul>
<li><code>B</code> kombiniert mit den Permutationen von <code>CDEF</code>
<ul>
<li><code>C</code> kombiniert mit den Permutationen von <code>DEF</code></li>
</ul></li>
</ul></li>
</ul>
<h1 id="collections"><span class="header-section-number">3</span> Collections</h1>
<p>Datenstrukturen dienen zur effizienten Speicherung und Verarbeitung von <em>Mengen</em> von Daten.</p>
<ul>
<li>Verarbeitung: Funktionen, die einzelne Objekte bearbeiten, nach bestimmten Objeken suchen, sie zählen, filtern, nach bestimmten Kriterien sortieren usw.</li>
</ul>
<p>Beispiele:</p>
<ul>
<li>Array</li>
<li>Tree</li>
<li>List</li>
<li>Map</li>
<li>Queue</li>
<li>Set</li>
<li>Stack</li>
</ul>
<p>Es gibt keine universelle Datenstruktur, die alles perfekt kann, sondern für jede Aufgabe mehr oder weniger geeignete Datenstrukturen.</p>
<h2 id="eigenschaften-von-datenstrukturen"><span class="header-section-number">3.1</span> Eigenschaften von Datenstrukturen</h2>
<ul>
<li>Grösse: dynamisch/statisch</li>
<li>Zugriff: direkt oder sequenziell</li>
<li>Sortierung: sortiert/unsortiert, mit/ohne Ordnung</li>
<li>Suche: beschleunigt?</li>
<li>Geschwindigkeit (von Operationen auf die Datenstruktur): Suchen, Einfügen, Anhängen, Entfernen, Verschieben</li>
</ul>
<h2 id="das-java-collection-framework"><span class="header-section-number">3.2</span> Das Java Collection Framework</h2>
<ul>
<li>Schnittstellen: abstrakte Datentypen</li>
<li>Implementierungen: konkrete Implementierungen der Schnittstellen</li>
<li>Algorithmen: (meist) polymorph implementierte Methoden zur Behandlung von Datenstrukturen, z.B.:
<ul>
<li><code>iterator()</code>: sequenzieller Zugriff auf alle Elemente</li>
<li><code>sort(List&lt;E&gt;)</code>: sortiert beliebige <code>List</code>-Implementierung</li>
</ul></li>
</ul>
<h3 id="grundlegende-funktionen-für-das-funktionieren-des-collection-frameworks"><span class="header-section-number">3.2.1</span> Grundlegende Funktionen für das Funktionieren des Collection-Frameworks</h3>
<ul>
<li>Sortierung: <code>equals()</code>, <code>Comparable&lt;T&gt;</code> (beide durch Element-Klasse implementiert), <code>Comparator&lt;T&gt;</code> (durch Client implementiert)</li>
<li>Hashing: <code>hashCode()</code> (durch Element-Klasse implementiert)</li>
</ul>
<h3 id="arten-der-gleichheit"><span class="header-section-number">3.2.2</span> Arten der Gleichheit</h3>
<ul>
<li>Typgleichheit (wenn <code>instanceof true</code> zurückliefert, Objekte Instanzen gleicher Klassen sind); lockere Form der Gleichheit</li>
<li>Identität (das gleiche Objekt <code>==</code>); strengste Form der Gleichheit (gilt, wenn <code>equals()</code> nicht überschrieben wird)</li>
<li>Wertegleichheit (gilt, wenn <code>equals()</code> überschrieben wrude); am häufigsten verwendete Form der Gleichheit</li>
</ul>
<h2 id="beispiel-speicherverwaltung"><span class="header-section-number">3.3</span> Beispiel: Speicherverwaltung</h2>
<ul>
<li>Annahme (Vereinfachung): Speicher steht in linearem Adressraum zur Verfügung</li>
<li>Verwaltung mittels Allokationen: jede Allokation speichert Startadresse und eine Grösse</li>
<li>Problematik bei der Verschiebung von Speicherblöcken: Aktualisierung der darauf verweisenden Zeiger</li>
<li>Freigegebener Speicher wird bloss als nicht besetzt markiert, aber nicht mit 0 überschrieben</li>
</ul>
<h3 id="anforderungen-an-die-speicherverwaltung"><span class="header-section-number">3.3.1</span> Anforderungen an die Speicherverwaltung</h3>
<ul>
<li>Zuverlässigkeit (keine Leaks)</li>
<li>Schnell: keine lange Suche nach passendem, freien Block bei Allokation; bei Freigabe</li>
<li>Zusammenfassen nebeneinanderliegender Lücken (Umgang mit Fragmentierung)</li>
<li><p>Welche Datenstruktur eignet sich dazu am besten? (eine Tabelle bzw. Map)</p></li>
<li>Belegungsstrategie
<ul>
<li>erster passender Block</li>
<li>noch kleinster, passender Block</li>
</ul></li>
<li>Freigabestrategie
<ul>
<li>erkennen und verbinden benachbarter, freier Blöcke</li>
<li>idealer Zeitpunkt zum Zusammenfügen</li>
</ul></li>
<li><p>geeignete Datenstruktur</p></li>
</ul>
<h1 id="datenstrukturen"><span class="header-section-number">4</span> Datenstrukturen</h1>
<h2 id="eigenschaften-von-datenstrukturen-1"><span class="header-section-number">4.1</span> Eigenschaften von Datenstrukturen</h2>
<ul>
<li>Datenstruktur als reine Sammlung: ungeordnete Ablage, nicht deterministische Reihenfolge (Analogie: Steinhaufen), keine Elemente dürfen verloren gehen</li>
<li>Datenstruktur mit einer bestimmten Reihenfolge: Reihenfolge bleibt (Analogie: Bücherstapel)</li>
<li>Datenstruktur, die Elemente (beim Einfügen) sortieren (Analogie: vollautomatisches Hochregallager)</li>
</ul>
<h2 id="operationen-auf-datenstrukturen"><span class="header-section-number">4.2</span> Operationen auf Datenstrukturen</h2>
<p>Grundlegende Operationen:</p>
<ul>
<li>Einfügen von Elementen</li>
<li>Suchen von Elementen</li>
<li>Entfernen von Elementen</li>
<li>Ersetzen von Elementen: Kombination von Suchen, Entfernen und Einfügen</li>
</ul>
<p>Operationen in Abhängigkeit von Reihenfolge oder Sortierung:</p>
<ul>
<li>Nachfolger</li>
<li>Vorgänger</li>
<li>Sortierung</li>
<li>Minimum/Maximum</li>
</ul>
<h2 id="statisch-oder-dynamisch"><span class="header-section-number">4.3</span> Statisch oder dynamisch</h2>
<ul>
<li>statisch: feste, bei der Initialisierung definierte Grösse (Analogie: Flasche, benötigt und bietet immer gleich viel Platz)
<ul>
<li>Vorteile:
<ul>
<li>Grösse immer bekannt (einfache Planbarkeit)</li>
<li>einfache Implementierung</li>
<li>einfache Adressierbarkeit (Direktzugriff auf Elemente)</li>
</ul></li>
<li>Nachteile:
<ul>
<li>Aufwändige Operationen erforderlich, wenn die Kapazität ausgeschöpft ist</li>
<li>Verschwendung bei geringer Auslastung</li>
</ul></li>
</ul></li>
<li>dynamisch: kann Grösse während Lebensdauer verändern und theoretisch beliebig viele Elemente aufnehmen (Analogie: Luftballon)
<ul>
<li>Vorteile:
<ul>
<li>Man braucht sich bei der Erstellung keine Gedanken darüber zu machen, wie viele Daten gespeichert werden müssen</li>
<li>keine Platzverschwendung (besonders zu Beginn)</li>
</ul></li>
<li>Nachteile:
<ul>
<li>Schwieriger zu implementieren</li>
<li>Aufwändigere Operationen (ständig neue Speicherallokationen notwendig)</li>
</ul></li>
</ul></li>
</ul>
<h2 id="element-beziehungen-explizit-oder-implizit"><span class="header-section-number">4.4</span> Element-Beziehungen: explizit oder implizit</h2>
<ul>
<li>explizit: Elemente sind miteinander verknüpft; Elemente kennen ihre Nachbarglieder
<ul>
<li>Analogie: Fahrradkette</li>
<li>Beispiel: (doppelt) verkettete Liste</li>
</ul></li>
<li>implizit: Beziehungen zwischen Elementen nicht von Elementen festgehalten, sondern von übergeordneter Struktur
<ul>
<li>Analogie: Bücherregal</li>
<li>Beispiel: Array, Liste, Map</li>
</ul></li>
</ul>
<h2 id="zugriff-direkt-oder-indirekt-sequenziell"><span class="header-section-number">4.5</span> Zugriff: direkt oder indirekt (sequenziell)</h2>
<ul>
<li>direkter Zugriff
<ul>
<li>sofort auf ein beliebiges Element zugreifen (mittels Index oder Key)</li>
<li>Beispiel: Speicheradresse im Computuer</li>
</ul></li>
<li>indirekter (sequenzieller) Zugriff
<ul>
<li>es müssen Vorgängerelemente durchlaufen werden, um auf ein bestimmtes Element zu kommen</li>
<li>Beispiel: Magnetband, Audio-Kasette, Java Streams</li>
</ul></li>
</ul>
<h2 id="aufwand-von-operationen"><span class="header-section-number">4.6</span> Aufwand von Operationen</h2>
<ul>
<li>variiert je nach Operation und Anzahl Elemente</li>
<li>vor allem die Ordnung interessant</li>
</ul>
<p>Beispiel: Stack konstant beim Einordnen, n² beim sortieren</p>
<h2 id="array"><span class="header-section-number">4.7</span> Array</h2>
<ul>
<li>in Java: Sprachelement</li>
<li>statisch</li>
<li>implizit</li>
<li>direkter Zugriff</li>
<li>Reihenfolge stabil</li>
<li>Aufwand
<ul>
<li>durchsuchen: <code>O(n)</code></li>
<li>sortieren: <code>O(log n)</code></li>
</ul></li>
</ul>
<h3 id="binäre-suche"><span class="header-section-number">4.7.1</span> Binäre Suche</h3>
<ul>
<li>in der Mitte teilen</li>
<li>anhand Trennelelent unterscheiden: links oder rechts weitersuchen?</li>
<li>rekursiv auf ausgewählte Hälfte wiederholen</li>
<li>fertig, wenn nur noch ein Element vorhanden ist</li>
</ul>
<h3 id="einfügen"><span class="header-section-number">4.7.2</span> Einfügen</h3>
<ul>
<li>unsortiert
<ul>
<li>wenn man sich letzten freien Platz merkt: <code>O(1)</code></li>
<li>ohne diesen Trick: <code>O(n)</code></li>
</ul></li>
<li>sortiert
<ul>
<li>Position suchen: <code>O(log n)</code></li>
<li>restliche Elemente nach rechts schieben: <code>O(n)</code></li>
<li>Aufwand: <code>O(n)</code></li>
</ul></li>
</ul>
<h3 id="entfernen"><span class="header-section-number">4.7.3</span> Entfernen</h3>
<ul>
<li>unsortiert (fortlaufend befüllt)
<ul>
<li>Position suchen: <code>O(n)</code></li>
<li>Entfernen und Lücke (mit beliebigem Element!) schliessen: <code>O(1)</code></li>
<li>Aufwand: <code>O(n)</code></li>
</ul></li>
<li>sortiert (fortlaufend befüllt)
<ul>
<li>Position suchen: <code>O(log n)</code></li>
<li>Entfernen und Lücke (mittels nach links durchschieben!) schliessen: <code>O(n)</code></li>
<li>Aufwand: <code>O(n)</code></li>
</ul></li>
</ul>
<h3 id="empfehlungen"><span class="header-section-number">4.7.4</span> Empfehlungen</h3>
<p>Arrays sollten eingesetzt werden, wenn:</p>
<ul>
<li>die Datenmenge <em>beschränkt</em>, von anfang an <em>bekannt</em> und eher <em>klein</em> ist</li>
<li>die Datentypen <em>elementar</em> sind, also eine bekannte und konstante Grösse haben</li>
</ul>
<p>Sonst sind Collections, wie z.B. eine <code>ArrayList</code>, vorzuziehen.</p>
<h2 id="listen"><span class="header-section-number">4.8</span> Listen</h2>
<p>TODO: p.20-</p>
<h2 id="stack"><span class="header-section-number">4.9</span> Stack</h2>
<p>TODO: p.31-</p>
<h2 id="queue"><span class="header-section-number">4.10</span> Queue</h2>
<p>TODO: p.38-</p>
<h1 id="glossar"><span class="header-section-number">5</span> Glossar</h1>
<ul>
<li>Algorithmus: präzise festgelegtes Verfahren zur Lösung eines Problems bzw. einer Problemklasse; ein Lösungsverfahren (Rezept, Anleitung)-Operator)</li>
<li>Datenstruktur: ein Konzept zur <em>Speicherung und Organisation von Daten</em>. Sie ist durch die Operationen charakterisiert, welche Zugriffe und Verwaltung realisieren.</li>
<li>Rekursion: Aufzeigen eines Lösungsweges, wie ein schwieriges Problem auf ein gleichartiges aber einfacheres Problem zurückgeführt werden kann.</li>
</ul>
</body>
</html>
