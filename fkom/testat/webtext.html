<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <style type="text/css">
  body {
      font-family: sans-serif;
      margin: 0 auto;
      padding: 1em;
      max-width: 35em;
      font-size: 16px;
      line-height: 1.5;
  }
  
  p {
      text-align: justify;
      hyphens: auto;
  }
  
  pre {
      font-size: 80%;
  }
  
  h1 {
      font-size: 150%;
  }
  
  h1.title {
      text-align: center;
  }
  
  h1.subtitle {
      text-align: center;
      font-size: 120%;
  }
  
  h2 {
      font-size: 120%;
  }
  
  h2.author {
      text-align: center;
      font-weight: normal;
  }
  
  h3.date {
      font-size: 100%;
      text-align: center;
      font-weight: normal;
  }
  
  sup a {
      text-decoration: none;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">Linux und Textdateien</h1>
<h1 class="subtitle">Effizient arbeiten mit einfachen Mitteln</h1>
<h2 class="author">Patrick Bucher</h2>
<h3 class="date">11.04.2017</h3>
</div>
<p>Windows- und Mac-User schreiben Texte meistens mit <em>Microsoft Word</em>. Als Dateiformat verwenden sie <em>Office Open XML</em> (OOXML<sup><a href="#1">1</a></sup>). Mit <em>Libre Office Writer</em><sup><a href="#2">2</a></sup> gibt es eine kostenlose Alternative zu <em>Microsoft Word</em>. Diese Software verwendet ein eigenes Dateiformat: <em>OpenDocument Text</em> (ODT<sup><a href="#3">3</a></sup>).</p>
<p>Beide Programme (<em>Word</em> und <em>Writer</em>) untersützen beide Formate (OOXML und ODT). Im Gegensatz zu <em>Word</em> funktioniert aber <em>Writer</em> auch auf Linux. Hartgesottene Linux-User verwenden aber lieber einfache Textdateien zum Speichern und Bearbeiten ihrer Texte. Warum ist das so?</p>
<h1 id="unterschiede-zwischen-textdateien-und-ooxmlodt">Unterschiede zwischen Textdateien und <em>OOXML/ODT</em></h1>
<p>OOXML und ODT speichern Texte in einer komprimierten XML-Struktur ab. Einfache Textdateien haben keine solche Struktur, sondern bestehen nur aus einer Reihe von Zeichen. Dadurch ergeben sich einige Unterschiede in der Handhabung von OOXML/ODT-Dateien einerseits und Textdateien andererseits:</p>
<ol style="list-style-type: decimal">
<li>OOXML/ODT-Dateien lassen sich nur mit <em>Word</em> und <em>Writer</em> zuverlässig bearbeiten. Textdateien lassen sich mit einem beliebigen Texteditor bearbeiten.</li>
<li>OOXML/ODT-Dateien enthalten viele Zusatzinformationen für Formatierung, Struktur und zusätzliche Einstellungen. Textdateien haben diesen <em>Overhead</em> nicht, da sie nur die eigentlichen Nutzdaten enthalten.</li>
<li>OOXML/ODT-Dateien können nur so lange gelesen werden, wie die enstprechenden Programme dazu verfügbar sind. Textdateien, die nur aus einer Reihe von Zeichen bestehen, können immer gelesen werden.</li>
<li>OOXML/ODT-Dateien lassen sich nur im «WYSIWYG»-Modus («what you see is what you get») bearbeiten. Textdateien lassen sich auch als <em>Textstrom</em> bearbeiten.</li>
</ol>
<p>Aus den ersten drei Punkten ergeben sich drei offensichtliche Vorteile für Textdateien. Doch welche Vorteile bieten <em>Textströme</em>?</p>
<h1 id="anwendungsbeispiel-wörter-in-mehreren-artikeln-zählen">Anwendungsbeispiel: Wörter in mehreren Artikeln zählen</h1>
<p>Angenommen, wir haben eine Reihe von Artikeln; einmal im ODT-Format (Endung: <code>.odt</code>) und einmal im Textformat (Endung: <code>.txt</code>). Nun wollen wir herausfinden, welcher Artikel in Wörtern gemessen der längste ist. Mit unseren ODT-Dateien verfahren wir folgendermassen:</p>
<ol style="list-style-type: decimal">
<li>Wir öffnen den ersten Artikel mit <em>Writer</em>.</li>
<li>Wir gehen auf das Menü <em>Tools</em> und wählen den Eintrag <em>Word Count</em>.</li>
<li>Wir notieren uns den Dateinamen und die Anzahl Wörter dazu.</li>
<li>Wir schliessen den Artikel.</li>
<li>Wir wiederholen den Vorgang für den nächsten Artikel.</li>
</ol>
<p>Dieses Vorgehen ist sehr aufwändig. Zudem muss der ganze Vorgang zu einem späteren Zeitpunkt wiederholt werden, falls die Artikel in Zwischenzeit umgeschrieben wurden.</p>
<p>Mit Textdateien funktioniert das einfacher. Man verwendet einfach folgende Befehlszeile, die untenstehende Ausgabe ergibt:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt <span class="kw">|</span> <span class="fu">sort</span> -n -r

<span class="ex">2220</span> eigenes-bier-brauen.txt
<span class="ex">1739</span> berlinreise.txt
<span class="ex">1231</span> neues-aquarium.txt
 <span class="ex">893</span> im-stau.txt</code></pre></div>
<p>Doch was hat das ganze zu bedeuten? Schauen wir uns die Befehlszeile genauer an:</p>
<h2 id="der-wc-befehl">Der <code>wc</code>-Befehl</h2>
<ul>
<li><code>wc</code><sup><a href="#4">4</a></sup> steht für «word count» und zählt die Wörter in einer Datei.</li>
<li>Standardmässig gibt <code>wc</code> die Anzahl Zeilen, Wörter und Zeichen einer Datei aus. Mit dem Parameter <code>-w</code> (für «words») erhalten wir nur die Anzahl Wörter.</li>
<li>Mit <code>*.txt</code> übergeben wir dem Programm sämtliche Textdateien im Arbeitsverzeichnis.</li>
</ul>
<p><code>wc -w *.txt</code> ist der erste Teil des Befehls. Führte man ihn aus, erhielte man folgende Ausgabe:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt

<span class="ex">1739</span> berlinreise.txt
<span class="ex">2220</span> eigenes-bier-brauen.txt
 <span class="ex">893</span> im-stau.txt
<span class="ex">1231</span> neues-aquarium.txt</code></pre></div>
<p>Wir sehen die Anzahl Wörter in der ersten Spalte, doch die Zeilen sind nicht sortiert.</p>
<h2 id="die-ausgabe-an-sort-weiterleiten">Die Ausgabe an <code>sort</code> weiterleiten</h2>
<p>Über das Muster <code>*.txt</code> erhält <code>wc</code> die Dateien in alphabetischer Reihenfolge, und gibt sie auch in alphabetischer Reihenfolge wieder aus. Darum kommt jetzt <code>sort</code><sup><a href="#5">5</a></sup> zum Zug.</p>
<ul>
<li>Zwischen den Befehlen steht das Zeichen <code>|</code>. Das ist eine sogenannte <em>Pipe</em>, zu Deutsch etwa «Röhre». Eine Pipe nimmt die Ausgabe eines Programmes entgegen und leitet sie als Eingabe zum nächsten Programm weiter. <em>Der Text «fliesst» also wie ein Strom durch die Röhre.</em> (Textstrom)</li>
<li>Das nächste Programm ist <code>sort</code>, das Textzeilen in alphabetisch aufsteigender Reihenfolge sortiert.</li>
<li>Da wir keine alphabetische, sondern eine numerische Sortierung benötigen («100» wäre gemäss alphabetischer Sortierung kleiner als «9»), geben wir den Parameter <code>-n</code> («numeric») an.</li>
<li>Zudem soll die Reihenfolge nicht aufsteigend (die kleinste Zahl am Anfang) sondern absteigend (die grösste Zahl am Anfang) sein, was wir mit dem Parameter <code>-r</code> («reverse») machen.</li>
</ul>
<p>Wir haben gesehen, dass sich ein alltägliches Problem mithilfe von Textdateien und einfachen Programmen (<code>wc</code> und <code>sort</code>) effizienter lösen lässt als mit einer Textverarbeitung.</p>
<h1 id="quellen">Quellen</h1>
<ol style="list-style-type: decimal">
<li><span id="1"><a href="http://officeopenxml.com/">Office Open XML</a></span></li>
<li><span id="2"><a href="https://www.libreoffice.org/discover/writer/">LibreOffice Writer</a></span></li>
<li><span id="3"><a href="http://opendocumentformat.org/">Open Document Format</a></span></li>
<li><span id="4"><a href="http://pubs.opengroup.org/onlinepubs/009604499/utilities/wc.html">Der <code>wc</code>-Befehl</a></span></li>
<li><span id="5"><a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sort.html">Der <code>sort</code>-Befehl</a></span></li>
</ol>
</body>
</html>
