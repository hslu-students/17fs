<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Textdateien</h1>
<h1 class="subtitle">Effizienter arbeiten unter Linux</h1>
<h2 class="author">Patrick Bucher</h2>
<h3 class="date">07.04.2017</h3>
</div>
<p>Windows- und Mac-User schreiben Texte meistens mit <em>Microsoft Word</em>. Als Dateiformat verwenden sie <em>Office Open XML</em> (OOXML) und als Endung des Dateinamens <code>.docx</code>.</p>
<p>Mit <em>OpenOffice.org Writer</em> und <em>Libre Office Writer</em> gibt es eine kostenlose Alternative zu <em>Microsoft Word</em>. Diese Software verwendet ein eigenes Dateiformat: <em>OpenDocument Text</em> (ODT) mit der Dateiendung <code>.odt</code>.</p>
<p>Beide Programme – <em>Word</em> und <em>Writer</em> – untersützen mittlerweile beide Formate. Im Gegensatz zu <em>Word</em> funktioniert aber <em>Writer</em> auch auf Linux. Hartgesottene Linux-User verwenden aber lieber einfache Textdateien (<em>plain text</em>) zum Speichern und Bearbeiten ihrer Texte. Warum ist das so?</p>
<h1 id="unterschiede-zwischen-textdateien-und-ooxmlodt">Unterschiede zwischen Textdateien und <em>OOXML/ODT</em></h1>
<p>OOXML und ODT speichern Texte in einer komprimierten XML-Struktur ab. Einfache Textdateien haben keine solche Struktur, sondern bestehen nur aus einer Reihe von Zeichen. Dadurch ergeben sich einige Unterschiede in der Handhabung von OOXML/ODT-Dateien einerseits und Textdateien andererseits:</p>
<ol style="list-style-type: decimal">
<li>OOXML/ODT-Dateien lassen sich nur mit einigen wenigen Programmen (<em>Word</em>, <em>Writer</em>) zuverlässig bearbeiten. Textdateien lassen sich mit einem beliebigen Texteditor, wovon es hunderte gibt, bearbeiten.</li>
<li>OOXML/ODT-Dateien enthalten viele Zusatzinformationen für Formatierung, Struktur und zusätzliche Einstellungen. Textdateien haben diesen <em>Overhead</em> nicht, da sie nur die eigentlichen Nutzdaten enthalten.</li>
<li>OOXML/ODT-Dateien können nur so lange gelesen werden, wie die enstprechenden Programme dazu verfügbar sind. (Wer schon einmal eine alte <code>.wps</code>-Datei öffnen wollte, kennt das Problem.) Textdateien, die nur aus einer Reihe von Zeichen bestehen, können immer gelesen werden.</li>
<li>OOXML/ODT-Dateien lassen sich nur im „WYSIWYG“-Modus („what you see is what you get“) bearbeiten. Textdateien lassen sich auch als <em>Textstrom</em> bearbeiten.</li>
</ol>
<p>Aus den ersten drei Punkten ergeben sich drei offensichtliche Vorteile für Textdateien. Doch was hat man als Benutzer davon, wenn man eine Datei als <em>Textstrom</em> bearbeiten kann?</p>
<h2 id="anwendungsbeispiel-wörter-in-mehreren-artikeln-zählen">Anwendungsbeispiel: Wörter in mehreren Artikeln zählen</h2>
<p>Angenommen, wir haben eine Reihe von Artikeln; einmal im <em>OpenDocument Text</em>-Format (<code>.odt</code>) und einmal im Textformat (<code>.txt</code>). Nun wollen wir herausfinden, welcher Artikel in Wörtern gemessen der längste ist. Mit unseren <em>OpenDocument Text</em>-Dateien verfahren wir folgendermassen:</p>
<ol style="list-style-type: decimal">
<li>Wir öffnen den ersten Artikel mit <em>Writer</em>.</li>
<li>Wir gehen auf das Menü <em>Tools</em> und wählen den Eintrag <em>Word Count</em>.</li>
<li>Wir notieren uns den Dateinamen und die Anzahl Wörter dazu.</li>
<li>Wir schliessen den Artikel.</li>
<li>Wir wiederholen den Vorgang für den nächsten Artikel.</li>
</ol>
<p>Dieses Vorgehen ist sehr aufwändig. Zudem muss der ganze Vorgang zu einem späteren Zeitpunkt wiederholt werden, falls die Dateien in Zwischenzeit bearbeitet wurden. Schliesslich könnte sich dadurch die Anzahl der Wörter verändert haben.</p>
<p>Mit Textdateien funktioniert das einfacher. Man verwendet einfach folgenden Konsolenbefehl bzw. folgende zwei, durch eine sogenannte <em>Pipe</em> verbundenen Befehle:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt <span class="kw">|</span> <span class="fu">sort</span> -n -r</code></pre></div>
<p>Dadurch erhält man folgende Ausgabe:</p>
<pre><code>2220 eigenes-bier-brauen.txt
1739 berlinreise.txt
1231 neues-aquarium.txt
 893 im-stau.txt</code></pre>
<p>Doch was hat das ganze zu bedeuten? Schauen wir uns die Befehlszeile genauer an:</p>
<h3 id="der-wc-befehl">Der <code>wc</code>-Befehl</h3>
<ul>
<li>Das <code>wc</code> zählt die Wörter in einer Datei. Der Programmname ist eine Abkürzung für „word count“.</li>
<li>Standardmässig gibt <code>wc</code> die Anzahl Zeilen, Wörter und Zeichen einer Datei aus. Wir interessieren uns aber nur für die Wörter. Darum geben wir den Parameter <code>-w</code> (für „words“) mit.</li>
<li>Mit <code>*.txt</code> geben wir dem Programm sämtliche Textdateien im aktuellen Arbeitsverzeichnis zum Zählen.</li>
</ul>
<p>Das (<code>wc -w *.txt</code>) ist der erste Teil des Befehls. Führte man ihn aus, erhielte man folgende Ausgabe:</p>
<pre><code>1739 berlinreise.txt
2220 eigenes-bier-brauen.txt
 893 im-stau.txt
1231 neues-aquarium.txt</code></pre>
<h3 id="die-ausgabe-an-sort-weiterleiten">Die Ausgabe an <code>sort</code> weiterleiten</h3>
<p>Die Dateien sind alphabetisch und nicht nach Nummern sortiert. Das liegt daran, dass <code>wc</code> die Dateien über die Wildcard <code>*.txt</code> in alphabetischer Reihenfolge zur Bearbeitung erhält. Darum kommt jetzt der zweite Teil der Befehlszeile zum Zug:</p>
<ul>
<li>Zwischen den Befehlen steht das Zeichen <code>|</code>. Das ist eine sogenannte <em>Pipe</em>, zu Deutsch etwa „Röhre“. Eine Pipe nimmt die Ausgabe eines Programmes entgegen und leitet sie als Eingabe zum nächsten Programm weiter.</li>
<li>Das nächste Programm ist in diesem Fall <code>sort</code>, das Textzeilen in alphabetisch und in aufsteigender Reihenfolge sortiert.</li>
<li>Da wir aber keine alphabetische, sondern numerische Sortierung wollen (“100“ wäre gemäss alphabetischer Sortierung kleiner als „9“), geben wir den Parameter <code>-n</code> an.</li>
<li>Zudem soll die Reihenfolge nicht aufsteigend (die kleinste Zahl am Anfang) sondern absteigend (die grösste Zahl am Anfang) sein, was wir mit dem Parameter <code>-r</code> machen.</li>
</ul>
<h3 id="die-ausgabe-kürzen">Die Ausgabe kürzen</h3>
<p>Je mehr Artikel sich in unserem Verzeichnis befinden, desto länger wird die Ausgabe. Bei hunderten Artikel müssten wir bald nach oben scrollen, um zu sehen, welcher am meisten Wörter enthält. Nun könnte man natürlich die Sortierreihenfolge anpassen, sodass der Artikel mit den meisten Wörtern in der letzten Zeile steht. Dazu kann man einfach den Parameter <code>-r</code> beim <code>sort</code>-Befehl weglassen.</p>
<p>Eleganter ist es, die Ausgabe auf eine bestimmte Länge zu kürzen. Der <code>head</code>-Befehl nimmt beliebig viele Zeilen entgegen und gibt die per Parameter definierte Anzahl an Zeilen aus. Um die drei Artikel mit den meisten Wörtern zu ermitteln, kann man den Befehl <code>head -3</code> verwenden. Dieser Befehl wird wiederum über eine Pipe mit unserer Befehlszeile verbunden:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">wc</span> -w *.txt <span class="kw">|</span> <span class="fu">sort</span> -n -r <span class="kw">|</span> <span class="fu">head</span> -3</code></pre></div>
<p>Die Ausgabe könnte dann folgendermassen aussehen:</p>
<pre><code>9431 der-syrienkrieg.txt
8943 jahresrückblick-2016.txt
7131 tour-de-france_doping.txt</code></pre>
</body>
</html>
